{"meta":{"title":"CrashBoom","subtitle":"","description":"","author":"CrashBoom","url":"https://ambitioussong.github.io","root":"/"},"pages":[],"posts":[{"title":"二叉树算法框架","slug":"binary_tree_solution","date":"2022-09-15T03:45:19.000Z","updated":"2022-09-15T07:20:59.989Z","comments":true,"path":"2022/09/15/binary_tree_solution/","link":"","permalink":"https://ambitioussong.github.io/2022/09/15/binary_tree_solution/","excerpt":"对二叉树算法的学习，以及代码框架的提炼。","text":"前言最近发现一个很不错的博客，叫labuladong的算法小抄，博主专注分享他对计算机算法的学习经验和方法论式总结，看得受益匪浅，我特地也必须的支持了东神线下发行的书籍。这篇文章是在阅读他的二叉树算法篇后的一些提炼，以达到后续能快速温习、快速应用的目的。 二叉树解题的思维模式先直接援引labuladong的总结： 1. 是否可以通过遍历一遍二叉树得到答案？ 如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。 2. 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？ 如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 无论使用哪种思维模式，你都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？ 需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。 上面思维模式的总结很到位，掌握这个思维模式，我觉得可以从三个方面入手： 首先需要深刻理解什么是迭代和递归； 其次需要熟悉迭代和递归对应的代码框架； 最后需要多加练习和思考，训练出自己抽象问题看本质的能力。说直白点，就是套用框架解决问题的能力。 下面具体来讲讲这三个方面。 一、深刻理解迭代和递归直观表述 迭代：通过一个简单的变量（往往是数值型）来控制循环，实现对数据结构的遍历。 递归：方法循环调用本身（每次传入嵌套关系的或父子关系的对象），实现对数据结构的遍历。 形象记忆 迭代：主导循环的主体，犹如一个总控的机械探针，在数据节点之间游走。想像家里吃饭，爷爷盛好三碗🍚放在桌上，然后喊爸爸和孩子过来，三人依次端走一碗。 递归：主导循环的主体，犹如一个层层传递的接力棒，在数据节点之间相互传递。想像家里吃饭，爷爷盛了一碗🍚递给爸爸，爸爸先把🍚递给孩子。第一碗米饭到了孩子手上，爷爷盛的第二碗🍚再递给爸爸，爷爷盛的第三碗🍚就给自己了。 迭代和递归框架之外的细节两者的本质都是通过循环实现遍历，一个关键细节就是退出循环的时机，或者说是怎么退出循环，这就是循环的边界问题。例如变量到底是n还是n-1，是自身判空还是子节点判空。 二、迭代和递归的代码框架 迭代的代码框架// 迭代遍历数组 void traverse(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; &#125;&#125;// 迭代遍历单链表 void traverse(ListNode head) &#123; for (ListNode p = head; p != null; p = p.next) &#123; &#125;&#125; 递归的代码框架// 递归遍历数组void traverse(int[] arr, int i) &#123; if (i == arr.length) &#123; return; &#125; // 前序位置 traverse(arr, i + 1); // 后序位置&#125;// 递归遍历单链表void traverse(ListNode head) &#123; if (head == null) &#123; return; &#125; // 前序位置 traverse(head.next); // 后序位置&#125;// 递归遍历二叉树void traverse(TreeNode root) &#123; if (root == null) &#123; return; &#125; // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置&#125; 二叉树这种结构无非就是二叉链表，由于没办法简单改写成迭代形式，所以一般说二叉树的遍历框架都是指递归的形式。 只要是递归形式的遍历，都可以有前序位置和后序位置插入你的逻辑，分别在递归之前和递归之后。也就是说，深刻理解前中后序，是遍历二叉树过程中，处理每一个节点的三个特殊时间点：所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，把代码写在不同位置，代码执行的时机也不同。比如说，实现倒序打印一条单链表上所有节点的值，如果运用递归的框架，可以利用后序位置来操作。 总结起来就是，在递归框架中，我们只需要单独思考每一个节点应该做什么，其他的不用管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。 三、解决二叉树问题再次抛出思维模式 是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。 是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。递归的思路本质是分解问题的思路：每个节点层层解决了问题，全局的问题就解决了。 无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。 后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。一旦发现题目和子树有关，那大概率应该在后序位置写逻辑代码了。 抽象问题提炼本质可以通过题目实践，训练抽象问题和解决问题的能力。下面的表中列出几个典型的例子，题目来自力扣。 问题 抽象 实践思维模式 第 104 题「 二叉树的最大深度」：即根节点到「最远」叶子节点的最长路径上的节点数 需要遍历二叉树 解法1：遍历一遍二叉树时，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度；解法2：最大深度可以通过子树的最大深度推导出来，可以使用递归的框架 第 543 题「 二叉树的直径」，计算一棵二叉树的最长直径长度：直径即任意两个结点之间的路径长度 每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和；二叉树的最大深度通过遍历二叉树即可 递归框架计算子树的最大深度的同时，不断刷新整个二叉树的最长直径 第 226 题「 翻转二叉树」，输入一个二叉树根节点 root，把整棵树镜像翻转 需要遍历二叉树 解法1：遍历一遍二叉树时，让每个节点的左右子节点颠倒过来就行了；解法2：翻转整个二叉树可以通过翻转各个节点的子树实现，可以使用递归的框架 本文参考labuladong 的算法小抄 之东哥带你刷二叉树","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ambitioussong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://ambitioussong.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"算法","slug":"算法","permalink":"https://ambitioussong.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Markdown速查手册","slug":"markdown-grammar","date":"2022-07-26T08:15:18.000Z","updated":"2022-09-15T07:14:55.293Z","comments":true,"path":"2022/07/26/markdown-grammar/","link":"","permalink":"https://ambitioussong.github.io/2022/07/26/markdown-grammar/","excerpt":"查了用，用了忘，忘了再查。","text":"段落空行新建下一个段落 标题#(1-6个) 你的标题 引用&gt; &gt;&gt;(n个&gt;对应n层嵌套引用) 代码块1个制表符即可(代码块会持续到没有缩进的一行为止) 代码中的Markdown语法字符不生效。 行内代码用反引号``包住代码即可：`你的代码` 特殊场景： 行内代码中本身就要显示反引号，那就用多个反引号包住代码：``你的代码`` 列表无序列表-(空格) +(空格) *(空格) 有序列表1.(空格) 2.(空格) 特殊场景： 1. 列表项目中有多个段落，每个段落必须缩进1个制表符才能正确显示出段落的缩进效果； 2. 列表项目中有引用，&gt;也需要缩进1个制表符； 3. 列表项目中有代码块， 代码块需要缩进2个制表符。 链接行内式[链接文字](链接地址 &quot;链接标题&quot;) 释义： 1. 其中链接标题可选。如：[点我百度](http://www.baidu.com &quot;百度&quot;)； 2. 链接地址，可以是本地资源，使用相对路径即可。如：[关于我](/about/)。 参考式[链接文字][id] [id]:(空格)链接地址 链接标题 释义： 1. 在文章中链接的地方先打上标记，具体这个标记对应的链接地址，可以放在文件尾统一管理； 2. id不区分大小写； 3. id为空时，相当于和链接文字同名。 图片![图片的替代文字](图片网址) 释义： 1. 相比链接的语法，前面多了个感叹号； 2. 目前，还没有办法指定图片的宽高，如果需要，可以使用普通的&lt;img&gt;标签。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://ambitioussong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://ambitioussong.github.io/tags/Markdown/"}]},{"title":"视频剪辑入门","slug":"fcp-pracitce","date":"2022-07-21T06:39:48.000Z","updated":"2022-07-26T08:13:41.165Z","comments":true,"path":"2022/07/21/fcp-pracitce/","link":"","permalink":"https://ambitioussong.github.io/2022/07/21/fcp-pracitce/","excerpt":"当前，短视频行业发展迅速，在欣赏别人的作品时，自己也不免想尝试来个小制作。","text":"&#8195;&#8195;当前，短视频行业发展迅速，在欣赏别人的作品时，自己也不免想尝试来个小制作。适逢今后的工作中，也大概率有视频剪辑甚至制作的任务。心动不如行动，动手先学一学视频剪辑，于是有了这篇文章。 准备工作工欲善其事，必先利其器。第一步就是软件下载了，经过一番网上搜索，了解到主流使用的几款视频软件： FinalCutPro: Apple公司产品，使用体验更好； Premiere: Adobe公司产品，功能更强大； 剪映: 字节跳动公司产品，更易上手但功能有限； 综合对比后，我决定先入门学学FinalCutPro的用法。电脑环境：MacBook Pro；软件：FinalCutPro；素材：搜索视频、音频素材网站下载； 概念介绍 资源库 事件 项目 参考教程https://www.bilibili.com/video/BV1Xa411r7hi?p=1 实践目标将一段音频和几段短视频剪辑成一个音乐MV。 实践步骤 这里只是总结记录下几个主要步骤，详细操作请参考教程链接。 剪辑视频 选中视频素材，通过J,K,L快捷键可以控制倒播，暂停，顺播，I,O快捷键添加入点和出点，F,U快捷键添加和取消收藏 剪辑音频 将音频素材拖到时间轨道上，通过空格键控制播放和暂停，在需要的点位通过M快捷键，添加标记点，删除的话通过鼠标右键选择。 视频调速 将视频素材拖到时间轨道上，音频轨道上方，选中后通过Command+R快捷键，唤出视频的调速菜单。这里，我们选择调慢，一般需要勾选上防抖动： 视频质量选择光流（慢速一般需要通过算法补帧）： 添加字幕 通过Control+T快捷键添加字幕层，选中单个字幕层，在检查器中编辑其各种属性： 可以通过Option+鼠标拖拽的方式复制出新的一份字幕层，给各个片段添加各自的字幕。","categories":[{"name":"技多不压身","slug":"技多不压身","permalink":"https://ambitioussong.github.io/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"}],"tags":[{"name":"视频","slug":"视频","permalink":"https://ambitioussong.github.io/tags/%E8%A7%86%E9%A2%91/"}]},{"title":"程序员常用英语词汇","slug":"computer_vocabulary","date":"2022-07-20T06:04:33.000Z","updated":"2022-07-21T00:52:21.396Z","comments":true,"path":"2022/07/20/computer_vocabulary/","link":"","permalink":"https://ambitioussong.github.io/2022/07/20/computer_vocabulary/","excerpt":"程序员与计算机打交道，是将需求由人类语言最终转变成机器语言的过程，而这过程中的程序语言绝大部分都是英语书写。因此，英语能力直接关系着程序员的专业技术能力。","text":"&#8195;&#8195;程序员与计算机打交道，是将需求由人类语言最终转变成机器语言的过程，而这过程中的程序语言绝大部分都是英语书写。因此，英语能力直接关系着程序员的专业技术能力。&#8195;&#8195;这篇文章，是我在日常工作中，积累的一些常用英语词汇，在计算机领域中使用频率很高，熟练地运用这些术语，来表述你的需求或问题，能事倍功半的提高工作效率。&#8195;&#8195;词汇表也将长期更新。 常用词汇 中文 英文 禁止、禁用、取消、移除 disable、remove、dismiss、cancel、drop、abandon、prohibit、subtract 没有被调用 not be called、not respond to、no response、nothing happened、be ignored、no function 同步、一致；不一致 in/out of tune、consistency ；discrepancies、inconsistency 最佳实践、使用方法 best practice、usage 观察、监听 observe、listen 层次 hierarchy、level 撤销、回滚 revert、undo、rollback 基本事实、关键问题 nitty-gritty 确认 identify、confirm 特点、特色、特征 features、character 含蓄地、明确地 implicitly、explicitly 兼容的、兼容性 compatible、compatibility 升级、降级 upgrade、downgrade 结合、组合 in conjunction with、combine with 短暂的、持续的 ephemeral、persistent 单数、奇数 odd、even number 前端程序 front-end application 不新鲜的数据 stale data 转换 convert to 差异 discrepancy 流量 traffic 全面的、整体的 comprehensive、holistic 同步的 concurrent 连续的、间断的 serial、intermittent 同步、异步 synchronous、asynchronous 引入，合并 incorporate、import、migrate 命令，指令 directives 、command、order 灰化不能点击 greyed out 采用、方案 adoption、solution 判断、测量、猜测、估计 judge、gauge、guess、estimate 混乱 disorder、confusion、chaotic 消除、排除 exclude、eliminate、remove","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://ambitioussong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"词汇","slug":"词汇","permalink":"https://ambitioussong.github.io/tags/%E8%AF%8D%E6%B1%87/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-19T08:46:35.463Z","updated":"2022-07-22T09:05:53.550Z","comments":true,"path":"2022/07/19/hello-world/","link":"","permalink":"https://ambitioussong.github.io/2022/07/19/hello-world/","excerpt":"你好，世界。","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://ambitioussong.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://ambitioussong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"技多不压身","slug":"技多不压身","permalink":"https://ambitioussong.github.io/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://ambitioussong.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"算法","slug":"算法","permalink":"https://ambitioussong.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Markdown","slug":"Markdown","permalink":"https://ambitioussong.github.io/tags/Markdown/"},{"name":"视频","slug":"视频","permalink":"https://ambitioussong.github.io/tags/%E8%A7%86%E9%A2%91/"},{"name":"词汇","slug":"词汇","permalink":"https://ambitioussong.github.io/tags/%E8%AF%8D%E6%B1%87/"}]}